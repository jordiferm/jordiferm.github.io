<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <title>About NodeJS and Java</title> <meta name="description" content="Java vs NodeJS"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="http://jordiferm.github.io/about-nodejs-and-java"> <link rel="alternate" type="application/rss+xml" title="Clean Code" href="http://jordiferm.github.io/feed.xml"> <script src="/assets/js/modernizr.js"></script> </head> <body"> <main class="wrapper"> <header class="site-header"> <a href="#navbar" id="menu-burger" class="menu-burger">Menu <span class="nav-icon"></span> <svg x="0px" y="0px" width="54px" height="54px" viewBox="0 0 54 54"> <circle fill="transparent" stroke="#000000" stroke-width="1" cx="27" cy="27" r="25" stroke-dasharray="157 157" stroke-dashoffset="157"></circle> </svg> </a> <div id="navbar" class="navbar"> <div class="navigation-wrapper"> <div class="half-block"> <h2>Navigation</h2> <nav> <ul class="primary-nav"> <li><a href="/">Home</a></li> <li><a href="/blog">Blog</a></li> <li><a href="/about">About</a></li> <li><a href="http://github.com/jordiferm" target="_blank"><i class="icon icon-github"></i> Github</a></li> <li><a href="http://twitter.com/jordiferm" target="_blank"><i class="icon icon-twitter"></i> Twitter</a></li> <li><a href="/feed.xml" target="_blank"><i class="icon icon-feed"></i> RSS</a></li> </ul> </nav> </div> </div> </div> </header> <article class="post" itemscope itemtype="http://schema.org/BlogPosting"> <header class="post-header intro"> <div class="intro-in"> <h1 class="post-title" itemprop="name headline">About NodeJS and Java</h1> <p class="post-meta"><time datetime="2016-02-17T00:58:36+01:00" itemprop="datePublished">Feb 17, 2016</time></p> </div> </header> <div class="post-content container" itemprop="articleBody"> <h1 id="java-vs-nodejs">Java vs NodeJS</h1> <p>Sin duda uno de los temas de moda en internet en los sitios visitados por desarrolladores, arquitectos de software, etc…</p> <p>Me veo obligado a hablar sobre ello por dos motivos: Primero porqué la mayoría de publicaciones son demasiado tendenciosas y segundo porque durante el último año he tenido la suerte de poder ser arquitecto de un proyecto con nodeJS y de otro con Java.</p> <p>Intentaré ser el máximo objetivo, claro y analítico posible. Mi objetivo es que al leer este artículo tengáis más claro qué tecnología es mejor para implementar vuestra solución.</p> <p>Comparar NodeJS con Java no es correcto. Puesto que NodeJS es la implementación de una arquitectura con una serie de tecnologías y lenguajes y Java es en si un lenguaje.</p> <p>Lo correcto seria estudiar una solución a partir de tecnologías relacionadas con NodeJS o con tecnologías relacionadas con Java.</p> <p>vamos a ello:</p> <h1 id="solucin-nodejs">Solución NodeJS</h1> <p>¿Qué es NodeJS, cuales son sus virtudes, como es su arquitectura ? A continuación vamos a explicarlo:</p> <h2 id="arquitectura">Arquitectura</h2> <p>Node JS se compone de un núcleo implementado en C y C++ que consta del motor intérprete de Javascript V8 de Google, i la implementación de un patron de arquitectura event-driven con topología de event procesor en un solo thread para gestionar las peticiones.</p> <p><img src="/assets/images/nodevsjava/node_internal_structure.png" alt="NodeJs Structure" /></p> <p>Toda la entrada y salida es asincrona para asegurar que sea Non-Blocking, puesto que el procesador de eventos es de un solo thread.</p> <p>La idea es que el procesador de eventos escucha los eventos entrantes y los envia (usando la libreria Libuv) al proceso correspondiente. Libuv optimiza los threads priorizando el bajo consumo de recursos.</p> <p>Gestionando una petición HTTP cada petición genera un evento y se le asigna un proceso ligado a un callback luego es liberado el procesador para poder atender a otras peticiones o eventos. Cuando el proceso termina se llama al callback relacionado. El mismo comportamiento se reproduce cuando se realiza una operación de entrada y salida, por ejemplo escribir en un archivo.</p> <h3 id="beneficios">Beneficios</h3> <ul> <li>El primer beneficio de usar esta arquitectura es que se puede optimizar el consumo de recursos para peticiones simultanias. Por eso se suele decir que node es capaz de gestionar mas peticiones concurrentes con los mismos recursos que otros sistemas (p ej: Java Tradicional).</li> <li>Con entrada y salida asincrona en node podemos procesar un archivo mientras esta siendo procesado, lo que lo hace un buen candidato para aplicaciones con flujos de datos pesados.</li> </ul> <p><img src="/assets/images/nodevsjava/nodejs_event_loop.png" alt="NodeJs event loop" /></p> <h2 id="el-lenguaje">El Lenguaje</h2> <p>NodeJS esta íntimamente ligado a Javascript una de las piezas clave de su núcleo es el intérprete de Javascript Google V8. Este componente se dedica a ejecutar o procesar eventos con tareas escritas en scripts de Javascript.</p> <p><a href="https://en.wikipedia.org/wiki/JavaScript">JavaScript</a> es un lenguaje de programación interpretado, de alto nivel, dinámico, sin tipado fuerte y multi-paradigma. Es multi-paradigmo porque soporta los estilos de programación Orientada a Objetos, funcional y imperativa.</p> <p>Inicialmente fue diseñado para ejecutarse en la parte cliente de las tecnologías web. Los navegadores. Pero actualmente es usado también en <a href="https://en.wikipedia.org/wiki/Comparison_of_server-side_JavaScript_solutions">la parte servidor</a>.</p> <h3 id="beneficios-1">Beneficios</h3> <ul> <li>Debido al que usa Javascript nodeJS es bueno manejando JSON (La representación estándar de los objetos en Javascript) actualmente muy utilizado en para la serialización de objetos con los FrontEnds debido a la popularidad de uso de JavaScript en los clientes como los navegadores.</li> <li>Gracias también a Javascript en las aplicaciones web podemos escribir tanto el Front-End com o el Back-End en un mismo lenguaje.</li> <li>Al ser un lenguaje interpretado no tenemos que compilar para ejecutar nuestro código. Esto agiliza las pruebas.</li> </ul> <p><img src="/assets/images/nodevsjava/javascript_logo.png" alt="Javascript Logo" /></p> <h2 id="frameworks-y-herramientas">Frameworks y Herramientas</h2> <p>Una de las características que hace a un Framework interesante es que tenga todos los componentes necesarios para desarrollar nuestra solución.</p> <p>Existen <a href="http://nodeframework.com/">infinidad de Frameworks</a> implementados en base a NodeJS. Para diferentes necesidades, por ejemplo:</p> <ul> <li><a href="http://hapijs.com/">Hapi</a></li> <li><a href="http://krakenjs.com/">Kraken</a></li> <li><a href="http://sailsjs.org/">Sails</a></li> <li><a href="http://expressjs.com/">Express.js</a></li> <li><a href="http://loopback.io/">LoopBack</a></li> </ul> <p>De forma genérica en cualquier solución se necesita que un framework tenga soporte para:</p> <ul> <li>Control de dependencias</li> <li>Persistencia</li> <li>Generación de vistas</li> <li>Connectividad en tiempo real</li> <li>Configuración por entornos</li> <li>Implementación de patrones de diseño, de integración</li> <li>Buena integración con otros sistemas</li> <li>Seguridad, Authenticación y Autorización</li> <li>Logging</li> <li>Cache</li> <li>Monitorización</li> <li>Procesado masivo de datos</li> <li>Gestión de dependencias</li> <li>Testing</li> </ul> <p>Otra característica importante que necesita un buen Framework es que sea escalable.</p> <p>A demás de implementaciones web en Node tambien se desarrollan herramientas para automatizar tareas por ejemplo para generación de código, minificado de front-end, gestión de dependencias, etc… * <a href="http://gulpjs.com/">gulp</a> * <a href="https://www.npmjs.com/package/yo">yeoman</a> * <a href="http://bower.io/">bower</a> * etc…</p> <p>Sin duda pero una de las herramientas mas importantes de node es su gestor de paquetes. <a href="https://docs.npmjs.com/how-npm-works/packages">npm</a>, centrado en la definición de paquetes y sus dependencias con un repositorio central y gestión de versiones.</p> <h3 id="beneficios-2">Beneficios</h3> <ul> <li>Los Frameworks suelen tener la curba de entrada es muy rápida y disfrutan de las ventajas inherentes a JavaScript.</li> <li>La mayoria son OpenSource y hospedados en GitHub con gran cantidad de aportaciones y muy activos.</li> <li>Multiplataforma, el núcleo de NodeJS esta portado a varias plataformas y por tanto implicitamente sus herramientas</li> <li>Los packages de node se distribuyen a partir del código.</li> </ul> <p><img src="/assets/images/nodevsjava/frameworks.png" alt="Frameworks" /></p> <h2 id="la-comunidad">La Comunidad</h2> <p>Con unas cifras indudablemente grandes, a día de hoy, 241,473 paquetes en <strong>npm</strong> con más de 150 millones de descargas diarias y siendo javascript el lenguage más utilizado en GitHub: http://githut.info/ la <a href="https://nodejs.org/en/get-involved/">comunidad de NodeJS</a> es sin duda de gran importancia y a la que hay que tener en cuenta.</p> <h3 id="beneficios-3">Beneficios</h3> <ul> <li>Gran cantidad de soluciones y aportaciones.</li> <li>Soporte on-line</li> <li>Open Source</li> </ul> <h2 id="uso-adecuado">Uso adecuado</h2> <p>Todos los beneficios que acabamos de describir hacen a NodeJS adecuado o seductor para soluciones tipo:</p> <ul> <li><strong>Chat</strong>: al ser una aplicación ligera con mucho tráfico, mucho manejo de datos y poco proceso/computación. Su arquitectura event driven le va como anillo al dedo.</li> <li><strong>API REST sobre objectDB basada en Json</strong>: Reduciendo así el “impedance-mismatch” y por tanto el mapeo de datos y la carga computacional.</li> <li><strong>Data Streaming</strong> Su anatomia asincrona permite por ejemplo procesar archivos mientras se suben.</li> <li><strong>MicroServices</strong> Su microkernel permite con un mínimo de recursos construir servicios que hagan tareas singulares y se comuniquen con un ecosistema de servicios parecidos.</li> </ul> <hr /> <h1 id="limitaciones-de-la-solucion-nodejs">Limitaciones de la Solucion NodeJS</h1> <p>Una vez vistas las ventajas, vamos a estudiar las limitaciones, Las repasaremos apartado por apartado siguiendo el orden de los anteriores:</p> <h2 id="arquitectura-1">Arquitectura</h2> <p>Inicialmente la arquitectura de nodeJS presenta varios problemas:</p> <ul> <li><strong>Acoplamiento a V8</strong>: El núcleo de node no abstrae las llamadas a V8 y a demás está muy acoplado a él. Esto hace que sea muy difícil mantener el núcleo al día con los cambios de V8.</li> <li><strong>Single point of failure</strong>: Debido a que su procesador de eventos es “Single Thread” la plataforma tienen un “Single point of failure” lo que hace muy poco tolerante a los fallos. Un pico de peticiones intenso puede sobrecargar la cpu hasta que el gestor de eventos no pueda hacer tu trabajo esto saturará al servidor y bloqueará todas la peticiones y respuestas pendientes de servir.</li> <li><strong>Excepciones no controladas rompen el event loop</strong>: También por su naturaleza “Single Thread” si una excepción llega al procesador de eventos este romperá todo el servicio. Aunque podemos reiniciarlo la recuperación puede ser muy costosa y casi con toda seguridad perderemos todas las respuestas que teníamos pendientes, que por su rendimiento pueden ser muchas.</li> </ul> <p>Los patrones de diseño son muy buenos cuando se usan bien pero todo lo contrario cuando se usan mal.</p> <p>La arquitectura de NodeJS resulta útil para algunas soluciones pero cuando no es así necesitamos poder cambiar el modelo. Esto no es posible en NodeJS. Veamos, por ejemplo, el caso en que no necesitamos que la entrada y salida sea asíncrona.</p> <h3 id="io-asncrona">I/O Asíncrona</h3> <p>Hay muchísimos casos donde no me interesa tener I/O asíncrona:</p> <p>Por ejemplo en los casos en que el backend realiza cálculos o necesita llamar a servicios por orden o que la llamada a un servicio desencadena o no otra llamada segun su resultado. Por supuesto que node y Javascript me propone <a href="http://alexeypetrushin.github.io/synchronize/docs/index.html">muchas soluciones</a> para hacerlo, pero todas tienden a complicar el código y es un problema más que tengo que tener en cuenta.</p> <p>En los casos en los que no tengo que sincronizarlos sigo teniendo que lidiar con <a href="http://howtonode.org/promises">llamadas asincronas</a>, vuelvo a pagar coste de desarrollo cuando no tengo tan claro que me aporte nada sobre ninguna necesidad real de mi solución.</p> <p>Por ejemplo otro caso, si quiero hacer logs ordenados de mis operaciones de entrada y salida.</p> <h3 id="rendimiento">Rendimiento</h3> <p>Se pueden encontrar por la red <a href="https://dzone.com/articles/performance-comparison-between">comparaciones de rendimiento</a>, la arquitectura de NodeJS debería favorecer a contestar muchas peticiones por segundo. Lo interesante es que en la mayoría de soluciones no necesitamos tanto rendimiento y NodeJS nos impone un patrón de arquitectura. En muchas de ellas se habla de miles de peticiones por segundo. Tengamos en cuenta que por ejemplo Google.com tiene unos 5 mil millones de peticiones diarias, eso supone unas 50000 por segundo. En muchos casos 100 o 200 peticiones por segundo son más que suficientes.</p> <h2 id="el-lenguaje-1">El Lenguaje</h2> <blockquote> <p>JavaScript por su naturaleza tiende a empeorar muchísimo la calidad del código.</p> </blockquote> <p>Dicen que un trozo de código vale más que 1000 palabras. He seleccionado 2 trozos de código para representar la sensación que se tiene cuando se lee código Java o Javascript:</p> <p>Ejemplo de código Java originario de <a href="https://github.com/spring-projects/spring-data-rest/blob/76380eb65087146c8e297bf03a50653c1669fd33/spring-data-rest-webmvc/src/main/java/org/springframework/data/rest/webmvc/BasePathAwareHandlerMapping.java">Spring</a>:</p> <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Override</span>
<span class="kd">protected</span> <span class="n">HandlerMethod</span> <span class="nf">lookupHandlerMethod</span><span class="o">(</span><span class="n">String</span> <span class="n">lookupPath</span><span class="o">,</span> <span class="n">HttpServletRequest</span> <span class="n">request</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">MediaType</span><span class="o">&gt;</span> <span class="n">mediaTypes</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">MediaType</span><span class="o">&gt;();</span>
    <span class="kt">boolean</span> <span class="n">defaultFound</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">MediaType</span> <span class="n">mediaType</span> <span class="o">:</span> <span class="n">MediaType</span><span class="o">.</span><span class="na">parseMediaTypes</span><span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">getHeader</span><span class="o">(</span><span class="n">HttpHeaders</span><span class="o">.</span><span class="na">ACCEPT</span><span class="o">)))</span> <span class="o">{</span>
        <span class="n">MediaType</span> <span class="n">rawtype</span> <span class="o">=</span> <span class="n">mediaType</span><span class="o">.</span><span class="na">removeQualityValue</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">rawtype</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">configuration</span><span class="o">.</span><span class="na">getDefaultMediaType</span><span class="o">()))</span> <span class="o">{</span>
            <span class="n">defaultFound</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">rawtype</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">MediaType</span><span class="o">.</span><span class="na">ALL</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">mediaTypes</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">mediaType</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">defaultFound</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">mediaTypes</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">configuration</span><span class="o">.</span><span class="na">getDefaultMediaType</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">lookupHandlerMethod</span><span class="o">(</span><span class="n">lookupPath</span><span class="o">,</span> <span class="k">new</span> <span class="nf">CustomAcceptHeaderHttpServletRequest</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">mediaTypes</span><span class="o">));</span>
<span class="o">}</span></code></pre></div> <p>Ejemplo de código JavaScript originario de la <a href="https://github.com/caolan/async/blob/master/lib/async.js">libreria async</a></p> <div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">async</span><span class="p">.</span><span class="nx">forEachOfSeries</span> <span class="o">=</span>
    <span class="nx">async</span><span class="p">.</span><span class="nx">eachOfSeries</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">iterator</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">callback</span> <span class="o">=</span> <span class="nx">_once</span><span class="p">(</span><span class="nx">callback</span> <span class="o">||</span> <span class="nx">noop</span><span class="p">);</span>
        <span class="nx">obj</span> <span class="o">=</span> <span class="nx">obj</span> <span class="o">||</span> <span class="p">[];</span>
        <span class="kd">var</span> <span class="nx">nextKey</span> <span class="o">=</span> <span class="nx">_keyIterator</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
        <span class="kd">var</span> <span class="nx">key</span> <span class="o">=</span> <span class="nx">nextKey</span><span class="p">();</span>
        <span class="kd">function</span> <span class="nx">iterate</span><span class="p">()</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">sync</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">key</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">callback</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="nx">iterator</span><span class="p">(</span><span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">],</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">only_once</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">callback</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="p">{</span>
                    <span class="nx">key</span> <span class="o">=</span> <span class="nx">nextKey</span><span class="p">();</span>
                    <span class="k">if</span> <span class="p">(</span><span class="nx">key</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
                        <span class="k">return</span> <span class="nx">callback</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="p">(</span><span class="nx">sync</span><span class="p">)</span> <span class="p">{</span>
                            <span class="nx">async</span><span class="p">.</span><span class="nx">setImmediate</span><span class="p">(</span><span class="nx">iterate</span><span class="p">);</span>
                        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                            <span class="nx">iterate</span><span class="p">();</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}));</span>
            <span class="nx">sync</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nx">iterate</span><span class="p">();</span>
    <span class="p">};</span></code></pre></div> <p>Estos son dos códigos seleccionados al azar que creo que representan muy bien lo que nos solemos encontrar en Java y los que nos solemos encontrar en Javascript.</p> <p>En el primer ejemplo (Java) encontramos nombres descriptivos, complejidad ciclomática baja, funciones pequeñas que atienden a su responsabilidad. Como resultado, podemos hacernos una idea de lo que hace el código de inmediato.</p> <p>En el segundo caso (JavaScript), encontramos nombres de variables no descriptivos y ambiguos como: <strong>obj</strong>, <strong>callback</strong>, <strong>sync</strong>, control de errores sin excepciones que aumentan la complejidad ciclomatica, etc… Resultado: códigos mas difíciles de leer.</p> <p>Si queréis un ejemplo con códigos más similares aquí tenéis una <a href="https://github.com/dpaani/springmvc-shoppingcart-sample/blob/master/shoppingcart/src/main/java/com/codetosalvation/shoppingcart/web/controller/ShoppingCartController.java">cesta de la compra en Java</a> y <a href="https://github.com/krakenjs/kraken-example-with-shoppingcart/blob/master/controllers/cart/index.js">otra similar en JavaScript</a> En este ejemplo se ve como en Java se tiende a escribir más clases cada cual con su responsabilidad =&gt; (Clean Code) y en JavaScript es frecuente encontrar funciones largas con expresiones de distintos niveles de detalle en la misma función =&gt; (Bad Code).</p> <p>Des de luego que se puede escribir buen código independientemente del lenguaje. Pero en la práctica los códigos que encontramos en los proyectos Open Source en JavaScript son de una calidad de inferior. Quizá por su naturaleza multi-proposito, o porqué en Javascript no hay una sola forma de hacer las cosas, se pueden definir objetos de varias formas distintas, no hay tipado fuerte, etc… Al final no creo que los programadores que escriben proyectos OpenSource en Javascript sean peores sinó que el lenguaje no les ayuda para escribir código de calidad.</p> <h3 id="exception-handling">Exception handling</h3> <p>Al no tener tipos la gestión de excepciones en JavaScript pierde una de sus grandes bazas. ¿Como especializo el control de excepciones? En su esencia controlar excepciones es delegar el error a otro nivel o a otra capa. Cuando cazo una excepción es porque puedo actuar en consecuencia, aportar algo a ese control. En JavaScript no puedo seleccionar fácilmente que tipos de excepción voy a controlar y para ello me veo obligado a hacer comprobación de tipos en tiempo de ejecución.</p> <div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="k">try</span> <span class="p">{</span>
  <span class="nx">foo</span><span class="p">.</span><span class="nx">bar</span><span class="p">();</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">e</span> <span class="k">instanceof</span> <span class="nx">EvalError</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span> <span class="o">+</span> <span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">e</span> <span class="k">instanceof</span> <span class="nx">RangeError</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span> <span class="o">+</span> <span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">// ... etc</span>
<span class="p">}</span></code></pre></div> <p>A demás el control de excepciones en códigos de naturaleza asíncrona, en esencia con muchos callbacks, se complica muchísimo.</p> <h3 id="errores-en-tiempo-de-ejecucin">Errores en tiempo de ejecución</h3> <p>Por su naturaleza tan dinámica y al tener cosas como el no tipado fuerte, objetos basándonos en prototipos y ningún compilador muchos errores en JavaScript se producen en tiempo de ejecución. Las soluciones suelen ser incrementar la cobertura el testing. Las capas de testing suelen ser bastante difíciles de mantener ahora a la postre estoy obligado a cubrir con testing aspectos que con otros lenguajes no son necesarios.</p> <p>La deuda tecnológica es una de las grandes cosas a tener en cuenta en cualquier aplicación.</p> <h3 id="mismo-lenguaje-en-back-y-en-front">Mismo lenguaje en back y en Front</h3> <p>Realmente, si el BackEnd y el FrontEnd están separados como deberían, la cantidad de código que van a compartir es casi 0.</p> <p>A demás el perfil de los programadores de Front-End y el de los de BackEnd es muy distinto. Raramente un programador de FrontEnd entenderá las implicaciones derivadas por ejemplo de una consulta a la base de datos, y por el otro lado, rara vez un programador de BackEnd entenderá las consecuencias de hacer, por ejemplo, cambios en un CSS.</p> <p>Por tanto el poder compartir código en FrontEnd y en BackEnd no supone ninguna ventaja significativa.</p> <p><img src="/assets/images/nodevsjava/javascript-the-good-parts-the-definitive-guide.jpg" alt="Javascript Good Parts image" /></p> <h2 id="frameworks-y-herramientas-1">Frameworks y Herramientas</h2> <p>La mayoría de los frameworks desarrollados sobre NodeJS sufren de:</p> <h3 id="ciclos-de-desarrollo-demasiado-rpidos-rompiendo-compatibilidades">Ciclos de desarrollo demasiado rápidos rompiendo compatibilidades</h3> <p><a href="https://github.com/meteor/meteor/graphs/contributors">Por ejemplo meteor</a> desde febrero de 2011 a Febrero del 2016:</p> <ul> <li>649 Releases</li> <li>374 Ramas</li> <li>266 Contribuidores</li> </ul> <p>Cuando <a href="https://github.com/spring-projects/spring-framework">Spring</a> con un periodo de tiempo 3 años mas largo y muchísimas más prestaciones:</p> <ul> <li>83 Releases (Y yo añadiría la pincelada de Estables)</li> <li>10 Ramas</li> <li>146 Contribuidores</li> </ul> <p>En demás proyectos los números son muy parecidos.</p> <p>Los cambios en los proyectos de NodeJS son muy elevados y normalmente poco rigurosos. Esto complica mucho mantenerse al día. Supone que nuestra solución se tenga que afianzar con unas versiones concretas de nuestras dependencias.</p> <p>NodeJS también permite tener <a href="http://maxogden.com/nested-dependencies.html"><strong>“Nested Dependencies”</strong></a>, de forma que las dependencias transitivas (Dependencias de mis dependencias) pueden formar un árbol con diferentes versiones de librerías entre sus nodos. Esto por un lado provoca que no se fuercen los cambios, pero por otro y en la práctica duplica considerablemente el número de archivos y de instancias de objetos a memoria, claro. <img src="/assets/images/nodevsjava/nested-deps.png" alt="Nested deps image" /></p> <p>Por ejemplo en uno de mis proyectos con módulos de node habituales y básicos, grunt, karma, jshint tengo en local 39462 archivos de dependencias.</p> <h3 id="documentaciones-muy-pobres">Documentaciones muy pobres</h3> <p>Comparando por ejemplo la documentación de <a href="http://sailsjs.org/documentation/concepts/">Sails</a> o <a href="http://expressjs.com/en/guide/routing.html">ExpressJS</a> con <a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/">Solo una parte pequeña de Spring</a> vemos que al menos por la cantidad ya hay una diferencia podríamos decir de unas 300 linias a 1.</p> <p>Si nos fijamos en la calidad habrá muchas opiniones pero normalmente los ciclos tan rápidos de cambios, ramas y aportaciones también condicionan que la calidad de la documentación de los frameworks de NodeJS tienda a la baja.</p> <h3 id="fullstack-">FullStack ?</h3> <p>¿Qué le pido a un Framework ?</p> <p>Lo primero que busco en un Framework es compatibilidad, cohesión, capacidad para dar una amplia gama de soluciones con una misma base. Si comparamos el Framework de NodeJS con mas prestaciones con Spring, tenemos que el Framework de node no llega a darnos ni un 10% de lo que nos da Spring.</p> <p>A día de hoy No he encontrado frameworks en NodeJS con todas necesidades básicas como:</p> <ul> <li>Control de dependencias</li> <li>Persistencia</li> <li>Generación de vistas</li> <li>Connectividad en tiempo real</li> <li>Configuración por entornos</li> <li>Implementación de patrones de diseño, de integración</li> <li>Buena integración con otros sistemas</li> <li>Seguridad, Authenticación y Autorización</li> <li>Logging</li> <li>Cache</li> <li>Monitorización</li> <li>Procesado masivo de datos</li> <li>Gestión de dependencias</li> <li>Testing</li> </ul> <p>Eso no significa que no tenga librerías para cubrirlo todo, significa que estas librerías no forman un Framework y por tanto no se han puesto de acuerdo. Para llegarlas a integrar puede que necesite conocerlas mejor que el desarrollador.</p> <p>¿Que me pasará por ejemplo si quiero integrar un servicio SOAP con nodeJS y que intervenga por ejemplo en middleware de Sails?</p> <h3 id="despliege">Despliege</h3> <p>No existe tampoco ningún estándar o sistema de empaquetado para nodeJS, los despliegues en el servidor suelen ser con herramientas para ejecutar como un servicio de forma redundante el núcleo de node. Se suele también versionar cada proyecto con el código de todas sus dependencias debido a que a veces npm tiene problemas de conectividad, caches, etc…</p> <h2 id="la-comunidad-1">La Comunidad</h2> <p>Una comunidad muy grande no tiene porque ser una ventaja. La calidad de las aportaciones es muy importante, también para facilitar a los integradores el poder incluir estas aportaciones de forma estable y segura. Indiscutiblemente el punto de entrada a NodeJS es muy rápido, mucho mas que en Java seguramente. Esto es bueno porque aporta programadores pero se convierte en malo cuando estos programadores no son de calidad. Al final que empecemos a hacer programas no significa que seamos buenos programadores.</p> <h2 id="uso-adecuado-1">Uso adecuado</h2> <p>Hemos hablado de que NodeJS es adecuado en algunos casos, pero cuando no es adecuado:</p> <ul> <li>En sistemas con Bd Relacionales. Debido a la immadurez de los ORM y de la necesidad de hacer llamadas síncronas.</li> <li>Si tuviéramos uso intensivo de CPU (Bloquearía la respuesta de Node)</li> <li>En bd NoSQL donde los objetos no sean JSON.</li> </ul> <p>En los que supuestamente es adecuado hay que perfilar más. Por ejemplo que pasa con un servicio de Streaming que analice en tiempo real los datos ? Usará la CPU no ?</p> <h3 id="y-en-los-microservices-">¿ Y en los <strong>MicroServices</strong> ?</h3> <p>En un ecosistema de ese tipo, necesito gestores de configuración centralizados, sistemas para autodiscovery de servicios activos, circuit breakers, global locks, sesiones distribuidas, leadership elections, …</p> <p>¿Qué Framework me proporciona esto? ¿Si uso distintas librerías Node que problemas de integración me supone? ¿Y si me integro con otras soluciones de distintas tecnologias?</p> <blockquote> <p>Todo esto me hace pensar si hay alguna otra solución en el mercado con la que pueda disponer de las ventajas de Node sin sus limitaciones:</p> </blockquote> <hr /> <h1 id="solucin-java">Solución Java</h1> <p><img src="/assets/images/nodevsjava/Java_Logo.jpg" alt="Java Logo" /></p> <p>Solemos identificar Java con sus modelos clásicos a menudo propuestos por Sun Microsystems, como la <a href="http://download.oracle.com/otn-pub/jcp/servlet-3.0-fr-eval-oth-JSpec/servlet-3_0-final-spec.pdf?AuthParam=1456183031_2f62340d91f6ca0dcfb9c7e2004df9ba">especificación de Servlets</a> lo interesante es que soluciones con la arquitectura de NodeJS ya existen en Java incluso desde antes que node. El problema fue quizá que al asociarse Java con su modelo tradicional, nadie lo tubo en cuenta como solución.</p> <h2 id="arquitectura-2">Arquitectura</h2> <p>Existen muchas implementaciones de la arquitectura de nodeJS en Java:</p> <ul> <li><a href="http://akka.io/">Akka</a></li> <li><a href="http://vertx.io/">Vert.x</a></li> <li><a href="https://www.playframework.com/">Play Framework</a></li> <li><a href="http://netty.io/">Netty</a></li> <li><a href="https://mina.apache.org/">Apache Mina</a></li> <li><a href="https://grizzly.java.net/">Grizzly</a></li> <li><a href="http://www.coralblocks.com/index.php/category/coralreactor/">CoralReactor</a></li> </ul> <p>Muchas de ellas más maduras que nodeJS. Luego el argumento de que la arquitectura de node es mejor que la de Java se ha de reformular quizá en que la arquitectura de NodeJS es mejor que la del modelo de aplicaciones web 3 capas o de servlet tradicional con el que se relaciona Java.</p> <p>Saliendo de implementaciones de terceros y volviendo a Java tradicional, Java soporta <a href="http://en.wikipedia.org/wiki/New_I/O">entrada y salida asíncrona</a> desde 2002 y Java SE 1.4. En 2009 la especificación de Servlet 3.0 estandarizó el procesado “Non-Blocking” pudiendo usarse si queremos servidores de aplicaciones tradicionales como GlassFish, Tomcat, Jetty o cualquier alternativa comercial.</p> <h3 id="beneficios-4">Beneficios</h3> <p>¿Cuales serian pues los beneficios de usar la implementación de una arquitectura como la de node en Java?</p> <h4 id="no-tengo-el-event-driven-impuesto">No tengo el event Driven Impuesto.</h4> <p>El modelo de Event Driven</p> <h4 id="no-tengo-el-modelo-asincrono-impuesto">No tengo el modelo asincrono impuesto</h4> <p>Debido a que existen modelos híbridos como Play, <a href="http://callistaenterprise.se/blogg/teknik/2014/04/22/c10k-developing-non-blocking-rest-services-with-spring-mvc/">Spring</a> o que es fácil implementar un método concreto de forma asíncrona. Si un proceso por ejemplo hace llamadas a una api que tienen que sincronizarse NodeJS pierde el sentido. No tenemos mas remedio que sincronizar código asíncrono cosa que complica nuestra implementación innecesariamente.</p> <p>En Java es muy fácil implementar una de nuestras llamadas de forma explicitamente asíncrona. Ejemplo llamada asíncrona en Java:</p> <div class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GitHubLookupService</span> <span class="o">{</span>

    <span class="n">RestTemplate</span> <span class="n">restTemplate</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">RestTemplate</span><span class="o">();</span>

    <span class="nd">@Async</span>
    <span class="kd">public</span> <span class="n">Future</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="nf">findUser</span><span class="o">(</span><span class="n">String</span> <span class="n">user</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Looking up &quot;</span> <span class="o">+</span> <span class="n">user</span><span class="o">);</span>
        <span class="n">User</span> <span class="n">results</span> <span class="o">=</span> <span class="n">restTemplate</span><span class="o">.</span><span class="na">getForObject</span><span class="o">(</span><span class="s">&quot;https://api.github.com/users/&quot;</span> <span class="o">+</span> <span class="n">user</span><span class="o">,</span> <span class="n">User</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="c1">// Artificial delay of 1s for demonstration purposes</span>
        <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000L</span><span class="o">);</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">AsyncResult</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;(</span><span class="n">results</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span></code></pre></div> <p>En este punto también podemos mencionar que existen implementaciones como <a href="http://akka.io/">akka</a> que facilitan la programación asíncrona muchísimo más que las de los actuales de NodeJS.</p> <h4 id="no-estoy-ligado-a-javascript">No estoy ligado a Javascript</h4> <p>Muchos lenguages compilan al ByteCode de Java, Por ejemplo Scala o Clojure, Groovy a demas son compatibles con sus herramientas de perfilado, gestión de dependéncias, etc…</p> <h4 id="performance">Performance</h4> <p>http://www.olympum.com/java/java-aio-vs-nodejs/</p> <h2 id="el-lenguaje-2">El Lenguaje</h2> <p>Java es un lenguaje de propósito general basado en clases y especialmente diseñado para tener el mínimo de dependencias posibles. Es de tipado fuerte y compilado con la peculiaridad que se compila a un bytecode que lo ejecuta una máquina virtual. Al existir esa máquina virtual para todas las plataformas el código compilado de java puede funcionar en todas las plataformas.</p> <p>En esencia mucho más eficiente que Javascript. V8 esta evolucionado en la parte cliente y Java lleva más de 20 años optimizando sus compiladores. Sin incluir NodeJS tenemos una penalización extra con los bindings de Node a V8. Aquí tenemos algunos ejemplos y pruebas de rendimiento: * <a href="http://benchmarksgame.alioth.debian.org/u32/javascript.html">Benchmark algoritmos</a> * <a href="https://medium.com/@tschundeee/express-vs-flask-vs-go-acc0879c2122#.9d4qj5p1d">Comparación peticiones por segundo con distintos Frameworks</a></p> <p>Java No tiene las limitaciones que hemos hablado anteriormente para el control de excepciones, los errores en tiempo de ejecución, etc… Y a diferencia de JavaScript tiende a obligar a escribir buen código. Por ejemplo puede imponer que se implemente una interfaz. Java, debido a sus contratos y su tipado fuerte es un lenguaje más Auto Documentado “Self-Documenting”. Esta es una característica que cobra mucha importancia en proyectos grandes. Pero es que a demás en términos de cantidad de proyectos que usan el lenguaje la adopción de java en los últimos años ha sido incluso <a href="https://github.com/blog/2047-language-trends-on-github">superior al de Javascript</a>.</p> <p>A demás existen alternativas a lenguajes que compilan a byteCode de Java como scala o Clojure, Groovy, etc con los que puedo integrarme a nivel binario.</p> <h2 id="frameworks-y-herramientas-2">Frameworks y Herramientas</h2> <p>En el mundo de los Frameworks y las Herramientas existen una mayor cantidad en Java que en Node. Por ejemplo mirando a los repositorios de paquetes: De los 243k paquetes en <a href="https://www.npmjs.com">npm</a> pasamos a los 1246k en el <a href="http://mvnrepository.com/">repositorio de maven</a> 5 veces mas. Voy a enumerar unas cuantas herramientas y frameworks que conozco personalmente:</p> <ul> <li>Maven o Gradle con mas capacidades que npm</li> <li>librerías de Monitorización como <a href="https://dropwizard.github.io/metrics/3.1.0/">Metrics</a></li> <li>Para logging <a href="http://logback.qos.ch/">LogBack</a></li> <li>Para control de versiones en BD: <a href="http://www.liquibase.org/">Liquibase</a></li> <li>Cache <a href="http://www.ehcache.org/">EHCache</a>, <a href="https://hazelcast.com/">HazelCast</a></li> <li>Tests <a href="http://mockito.org/">Mockito</a>, <a href="http://junit.org/">JUnit</a></li> <li>Persistencia <a href="http://hibernate.org/">Hibernate</a></li> <li>Componentes graficos <a href="https://vaadin.com/home">Vaadin</a></li> <li>Gestión de repositorios <a href="http://www.sonatype.com/nexus/solution-overview">Nexus</a></li> <li>Serialización <a href="https://github.com/FasterXML/jackson">Jackson</a></li> <li>Reporting <a href="http://community.jaspersoft.com/project/jasperreports-library">Jasper Reports</a> *</li> </ul> <p>Pero si hablamos de Frameworks existe uno que se lleva el premio Gordo.</p> <p><a href="http://spring.io/projects">Spring Framework</a></p> <p>Spring nació en <strong>2002</strong> para simplificar el desarrollo de Java partiendo con un núcleo de IOC o inyeccion de dependencias y AOP.</p> <p><img src="/assets/images/nodevsjava/spring-overview.png" alt="Spring Overview" /></p> <p>Una de las muchas cosas que ha hecho muy bien Spring es integrar un <a href="https://spring.io/projects">ecosistema de librerías</a> para tener el honor de poderse llamar Full Stack:</p> <ul> <li><strong>Spring Boot</strong> (Configuració, staging, ejecución)</li> <li><strong>Spring Framework</strong> (Núcleo de Spring, IOC, AOP, Acceso de datos, web apps, messaging y mucho más)</li> <li><strong>Spring XD</strong> (Big Data)</li> <li><strong>Spring Cloud</strong> (Todo lo necesario para MicroServices, Configuration management, service discovery, micro-proxy, circuit breakers, sesiones distribuidas, etc…)</li> <li><strong>Spring Data</strong> (Persistencia, Sql, NoSQL, map-reduce, etc)</li> <li><strong>Spring Batch</strong> (Procesado de volumenes grandes de datos)</li> <li><strong>Spring Integration</strong> (Todos los patrones Enterprise Integration, Adaptadores declarativos)</li> <li><strong>Spring Security</strong> (Authorizacion y Authenticación totalmente extensible)</li> <li><strong>Spring HATEOAS</strong> (Nivel 3 de RestFUL)</li> <li><strong>Spring Social</strong> (Integracion con redes sociales)</li> <li><strong>Spring AMPQ</strong> (Patrones de Message queues)</li> <li><strong>Spring Mobile</strong> (Deteccion de dispositivos, desarollo de webapps para móbiles)</li> <li><strong>Spring Web Services</strong> (Integración con Servicios contract-first SOAP)</li> <li><strong>Spring Session</strong> (Distintas implementaciones de gestión de sessiones de usuario)</li> <li>etc…</li> </ul> <p>Otra gran virtud de Spring es que es extremadamente escalable. Todas las capas que deben son abstractas. Por ejemplo la gestión de sesiones, de cache, de Transacciones todo es reimplementable o intercambiando piezas, configurando el contexto hago cosas como cambiar la persistencia de sesión sin tocar nada más que una definición de Bean.</p> <h2 id="la-comunidad-2">La Comunidad</h2> <p>Las herramientas conservan las ventajas de ser comunidades de código abierto, pero suelen priorizar la estabilidad y compatibilidad de los proyectos, los códigos no son tan crípticos ni las aportaciones tan descontroladas y caóticas.</p> <h2 id="uso-adecuado-2">Uso adecuado</h2> <p>Para todos los usos adecuados en NodeJS encontramos igual o mejores soluciones en Java y también para todos los usos no adecuados en node. De forma que Java me sirve para un mayor catálogo de soluciones. Aprender Java es mejor inversión y me permite sobretodo mantener soluciones a largo plazo.</p> <hr /> <h1 id="en-resumen">En resumen</h1> <p>El rápido punto de entrada de NodeJs resulta muy atractivo para acercar a los programadores de Front-End al Back-End, también es una buena herramienta para soluciones simples, prototipos y pruebas de concepto.</p> <p>Pero para proyectos de cierta duración, envergadura y robustez no nos interesa un punto de entrada rápido, sino perfiles con amplio conocimiento de los patrones de diseño y arquitecturas que hay que aplicar. En estos casos, Java es mejor herramienta.</p> <hr /> <h1 id="apendice-experiencias-en-nodejs">Apendice: Experiencias en NodeJS</h1> <h2 id="gad">Gad</h2> <p>Mi experiencia en NodeJS con Sails y Restful. La aproximación fue inmediata, pero a la semana de trabajo ya empezamos a leer código de Sails por poca documentación. Luego al subir de complejidad la capa de servicio nos obligó a refactorizarla con poco éxito. Finalmente procesos con llamadas a servicios sincronizadas nos ocuparon mucho mas tiempo del esperado. A la semana de subir a producción teniamos un problema grabe en Sails que se arregló en una nueva versión que al instalarla rompió toda la capa de servicio ya que habían cambiado interfaces de su api.</p> <h2 id="netflix">Netflix</h2> <p><a href="http://www.talentbuddy.co/blog/building-with-node-js-at-netflix/">Netflix uso NodeJs</a> uno de sus motivos fue para que sus front-enders pudieran escribir también backend</p> <h2 id="ebay">Ebay</h2> <p>Ebay tubo sus <a href="http://www.ebaytechblog.com/2013/05/17/how-we-built-ebays-first-node-js-application/">experiencias en node en 2013</a>, en ella reconocen que no comprobaron otras opciones diferentes que el modelo tradicional de servlets en Java. <img src="/assets/images/nodevsjava/ebay_testimony.png" alt="Ebay testimony" /></p> <hr /> </div> </article> <footer class="site-footer"> <div class="container"> <ul class="social"> <li><a href="http://github.com/jordiferm" target="_blank"><i class="icon icon-github"></i></a></li> <li><a href="https://es.linkedin.com/in/jordi-fernàndez-0056751b" target="_blank"><i class="icon icon-linkedin"></i></a></li> <li><a href="http://twitter.com/jordiferm" target="_blank"><i class="icon icon-twitter"></i></a></li> </ul> <p> <small>&copy;2016 All rights reserved. Made with <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> and ♥</small> </p> </div> </footer> </main> <script src="/assets/js/jquery-2.1.1.js"></script> <script src="/assets/js/main.js"></script> </body> </html><!-- by nandomoreira.me -->